'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FactoryProvider = exports.ClassProvider = exports.ProvidePromise = exports.Provide = exports.InjectLazy = exports.InjectPromise = exports.Inject = exports.TransientScope = exports.SuperConstructor = exports.readAnnotations = exports.hasAnnotation = exports.annotate = undefined;

var _util = require('./util');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// This module contains:
// - built-in annotation classes
// - helpers to read/write annotations


// ANNOTATIONS

// A built-in token.
// Used to ask for pre-injected parent constructor.
// A class constructor can ask for this.
var SuperConstructor = function SuperConstructor() {
  _classCallCheck(this, SuperConstructor);
};

// A built-in scope.
// Never cache.


var TransientScope = function TransientScope() {
  _classCallCheck(this, TransientScope);
};

var Inject = function Inject() {
  _classCallCheck(this, Inject);

  for (var _len = arguments.length, tokens = Array(_len), _key = 0; _key < _len; _key++) {
    tokens[_key] = arguments[_key];
  }

  this.tokens = tokens;
  this.isPromise = false;
  this.isLazy = false;
};

var InjectPromise = function (_Inject) {
  _inherits(InjectPromise, _Inject);

  function InjectPromise() {
    _classCallCheck(this, InjectPromise);

    var _this = _possibleConstructorReturn(this, (InjectPromise.__proto__ || Object.getPrototypeOf(InjectPromise)).call(this));

    for (var _len2 = arguments.length, tokens = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      tokens[_key2] = arguments[_key2];
    }

    _this.tokens = tokens;
    _this.isPromise = true;
    _this.isLazy = false;
    return _this;
  }

  return InjectPromise;
}(Inject);

var InjectLazy = function (_Inject2) {
  _inherits(InjectLazy, _Inject2);

  function InjectLazy() {
    _classCallCheck(this, InjectLazy);

    var _this2 = _possibleConstructorReturn(this, (InjectLazy.__proto__ || Object.getPrototypeOf(InjectLazy)).call(this));

    for (var _len3 = arguments.length, tokens = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      tokens[_key3] = arguments[_key3];
    }

    _this2.tokens = tokens;
    _this2.isPromise = false;
    _this2.isLazy = true;
    return _this2;
  }

  return InjectLazy;
}(Inject);

var Provide = function Provide(token) {
  _classCallCheck(this, Provide);

  this.token = token;
  this.isPromise = false;
};

var ProvidePromise = function (_Provide) {
  _inherits(ProvidePromise, _Provide);

  function ProvidePromise(token) {
    _classCallCheck(this, ProvidePromise);

    var _this3 = _possibleConstructorReturn(this, (ProvidePromise.__proto__ || Object.getPrototypeOf(ProvidePromise)).call(this));

    _this3.token = token;
    _this3.isPromise = true;
    return _this3;
  }

  return ProvidePromise;
}(Provide);

var ClassProvider = function ClassProvider() {
  _classCallCheck(this, ClassProvider);
};

var FactoryProvider = function FactoryProvider() {
  _classCallCheck(this, FactoryProvider);
};

// HELPERS

// Append annotation on a function or class.
// This can be helpful when not using ES6+.


function annotate(fn, annotation) {
  fn.annotations = fn.annotations || [];
  fn.annotations.push(annotation);
}

// Read annotations on a function or class and return whether given annotation is present.
function hasAnnotation(fn, annotationClass) {
  if (!fn.annotations || fn.annotations.length === 0) {
    return false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fn.annotations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var annotation = _step.value;

      if (annotation instanceof annotationClass) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
}

// Read annotations on a function or class and collect "interesting" metadata:
function readAnnotations(fn) {
  var collectedAnnotations = {
    // Description of the provided value.
    provide: {
      token: null,
      isPromise: false
    },

    // List of parameter descriptions.
    // A parameter description is an object with properties:
    // - token (anything)
    // - isPromise (boolean)
    // - isLazy (boolean)
    params: []
  };

  if (fn.annotations && fn.annotations.length) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = fn.annotations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var annotation = _step2.value;

        if (annotation instanceof Inject) {
          annotation.tokens.forEach(function (token) {
            collectedAnnotations.params.push({
              token: token,
              isPromise: annotation.isPromise,
              isLazy: annotation.isLazy
            });
          });
        }

        if (annotation instanceof Provide) {
          collectedAnnotations.provide.token = annotation.token;
          collectedAnnotations.provide.isPromise = annotation.isPromise;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  // Read annotations for individual parameters.
  if (fn.parameters) {
    fn.parameters.forEach(function (param, idx) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = param[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var paramAnnotation = _step3.value;

          // Type annotation.
          if ((0, _util.isFunction)(paramAnnotation) && !collectedAnnotations.params[idx]) {
            collectedAnnotations.params[idx] = {
              token: paramAnnotation,
              isPromise: false,
              isLazy: false
            };
          } else if (paramAnnotation instanceof Inject) {
            collectedAnnotations.params[idx] = {
              token: paramAnnotation.tokens[0],
              isPromise: paramAnnotation.isPromise,
              isLazy: paramAnnotation.isLazy
            };
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    });
  }

  return collectedAnnotations;
}

exports.annotate = annotate;
exports.hasAnnotation = hasAnnotation;
exports.readAnnotations = readAnnotations;
exports.SuperConstructor = SuperConstructor;
exports.TransientScope = TransientScope;
exports.Inject = Inject;
exports.InjectPromise = InjectPromise;
exports.InjectLazy = InjectLazy;
exports.Provide = Provide;
exports.ProvidePromise = ProvidePromise;
exports.ClassProvider = ClassProvider;
exports.FactoryProvider = FactoryProvider;