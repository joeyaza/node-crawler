'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createProviderFromFnOrClass = createProviderFromFnOrClass;

var _annotations = require('./annotations');

var _util = require('./util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isClass(clsOrFunction) {

  if ((0, _annotations.hasAnnotation)(clsOrFunction, _annotations.ClassProvider)) {
    return true;
  } else if ((0, _annotations.hasAnnotation)(clsOrFunction, _annotations.FactoryProvider)) {
    return false;
  } else if (clsOrFunction.name) {
    return (0, _util.isUpperCase)(clsOrFunction.name.charAt(0));
  } else {
    return (0, _util.ownKeys)(clsOrFunction.prototype).length > 0;
  }
}

// Provider is responsible for creating instances.
//
// responsibilities:
// - create instances
//
// communication:
// - exposes `create()` which creates an instance of something
// - exposes `params` (information about which arguments it requires to be passed into `create()`)
//
// Injector reads `provider.params` first, create these dependencies (however it wants),
// then calls `provider.create(args)`, passing in these arguments.


var EmptyFunction = Object.getPrototypeOf(Function);

// ClassProvider knows how to instantiate classes.
//
// If a class inherits (has parent constructors), this provider normalizes all the dependencies
// into a single flat array first, so that the injector does not need to worry about inheritance.
//
// - all the state is immutable (constructed)
//
// TODO(vojta): super constructor - should be only allowed during the constructor call?

var ClassProvider = function () {
  function ClassProvider(clazz, params, isPromise) {
    _classCallCheck(this, ClassProvider);

    // TODO(vojta): can we hide this.provider? (only used for hasAnnotation(provider.provider))
    this.provider = clazz;
    this.isPromise = isPromise;

    this.params = [];
    this._constructors = [];

    this._flattenParams(clazz, params);
    this._constructors.unshift([clazz, 0, this.params.length - 1]);
  }

  // Normalize params for all the constructors (in the case of inheritance),
  // into a single flat array of DependencyDescriptors.
  // So that the injector does not have to worry about inheritance.
  //
  // This function mutates `this.params` and `this._constructors`,
  // but it is only called during the constructor.
  // TODO(vojta): remove the annotations argument?


  _createClass(ClassProvider, [{
    key: '_flattenParams',
    value: function _flattenParams(constructor, params) {
      var SuperConstructor;
      var constructorInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var param = _step.value;

          if (param.token === _annotations.SuperConstructor) {
            SuperConstructor = Object.getPrototypeOf(constructor);

            if (SuperConstructor === EmptyFunction) {
              throw new Error((0, _util.toString)(constructor) + ' does not have a parent constructor. Only classes with a parent can ask for SuperConstructor!');
            }

            constructorInfo = [SuperConstructor, this.params.length];
            this._constructors.push(constructorInfo);
            this._flattenParams(SuperConstructor, (0, _annotations.readAnnotations)(SuperConstructor).params);
            constructorInfo.push(this.params.length - 1);
          } else {
            this.params.push(param);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // Basically the reverse process to `this._flattenParams`:
    // We get arguments for all the constructors as a single flat array.
    // This method generates pre-bound "superConstructor" wrapper with correctly passing arguments.

  }, {
    key: '_createConstructor',
    value: function _createConstructor(currentConstructorIdx, context, allArguments) {
      var constructorInfo = this._constructors[currentConstructorIdx];
      var nextConstructorInfo = this._constructors[currentConstructorIdx + 1];
      var argsForCurrentConstructor;

      if (nextConstructorInfo) {
        argsForCurrentConstructor = allArguments.slice(constructorInfo[1], nextConstructorInfo[1]).concat([this._createConstructor(currentConstructorIdx + 1, context, allArguments)]).concat(allArguments.slice(nextConstructorInfo[2] + 1, constructorInfo[2] + 1));
      } else {
        argsForCurrentConstructor = allArguments.slice(constructorInfo[1], constructorInfo[2] + 1);
      }

      return function InjectedAndBoundSuperConstructor() {
        // TODO(vojta): throw if arguments given
        return constructorInfo[0].apply(context, argsForCurrentConstructor);
      };
    }

    // It is called by injector to create an instance.

  }, {
    key: 'create',
    value: function create(args) {
      var context = Object.create(this.provider.prototype);
      var constructor = this._createConstructor(0, context, args);
      var returnedValue = constructor();

      if ((0, _util.isFunction)(returnedValue) || (0, _util.isObject)(returnedValue)) {
        return returnedValue;
      }

      return context;
    }
  }]);

  return ClassProvider;
}();

// FactoryProvider knows how to create instance from a factory function.
// - all the state is immutable


var FactoryProvider = function () {
  function FactoryProvider(factoryFunction, params, isPromise) {
    _classCallCheck(this, FactoryProvider);

    this.provider = factoryFunction;
    this.params = params;
    this.isPromise = isPromise;

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = params[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var param = _step2.value;

        if (param.token === _annotations.SuperConstructor) {
          throw new Error((0, _util.toString)(factoryFunction) + ' is not a class. Only classes with a parent can ask for SuperConstructor!');
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  _createClass(FactoryProvider, [{
    key: 'create',
    value: function create(args) {
      return this.provider.apply(undefined, args);
    }
  }]);

  return FactoryProvider;
}();

function createProviderFromFnOrClass(fnOrClass, annotations) {
  if (isClass(fnOrClass)) {
    return new ClassProvider(fnOrClass, annotations.params, annotations.provide.isPromise);
  }

  return new FactoryProvider(fnOrClass, annotations.params, annotations.provide.isPromise);
}