'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inject = exports.use = undefined;

var _injector = require('./injector');

var _annotations = require('./annotations');

var _util = require('./util');

var _providers = require('./providers');

var currentSpec = null;
beforeEach(function () {
  currentSpec = this;
  currentSpec.$$providers = [];
});

afterEach(function () {
  currentSpec.$$providers = null;
  currentSpec.$$injector = null;
  currentSpec = null;
});

function isRunning() {
  return !!currentSpec;
}

function use(mock) {
  if (currentSpec && currentSpec.$$injector) {
    throw new Error('Cannot call use() after inject() has already been called.');
  }

  var providerWrapper = {
    provider: mock
  };

  var fn = function fn() {
    currentSpec.$$providers.push(providerWrapper);
  };

  fn.as = function (token) {
    if (currentSpec && currentSpec.$$injector) {
      throw new Error('Cannot call as() after inject() has already been called.');
    }

    providerWrapper.as = token;
    if (isRunning()) {
      return undefined;
    }

    return fn;
  };

  if (isRunning()) {
    fn();
  }

  return fn;
}

function inject() {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  var behavior = params.pop();

  (0, _annotations.annotate)(behavior, new (Function.prototype.bind.apply(_annotations.Inject, [null].concat(params)))());

  var run = function run() {
    if (!currentSpec.$$injector) {
      var providers = new Map();
      var modules = [];
      var annotations;

      currentSpec.$$providers.forEach(function (providerWrapper) {
        if (!providerWrapper.as) {
          // load as a regular module
          modules.push(providerWrapper.provider);
        } else {
          if (!(0, _util.isFunction)(providerWrapper.provider)) {
            // inlined mock
            providers.set(providerWrapper.as, (0, _providers.createProviderFromFnOrClass)(function () {
              return providerWrapper.provider;
            }, { provide: { token: null, isPromise: false }, params: [] }));
          } else {
            // a fn/class provider with overridden token
            annotations = (0, _annotations.readAnnotations)(providerWrapper.provider);
            providers.set(providerWrapper.as, (0, _providers.createProviderFromFnOrClass)(providerWrapper.provider, annotations));
          }
        }
      });

      currentSpec.$$injector = new _injector.Injector(modules, null, providers);
    }

    currentSpec.$$injector.get(behavior);
  };

  return isRunning() ? run() : run;
}

exports.use = use;
exports.inject = inject;