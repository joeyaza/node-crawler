'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Injector = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _annotations = require('./annotations');

var _util = require('./util');

var _profiler = require('./profiler');

var _providers = require('./providers');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function constructResolvingMessage(resolving, token) {
  // If a token is passed in, add it into the resolving array.
  // We need to check arguments.length because it can be null/undefined.
  if (arguments.length > 1) {
    resolving.push(token);
  }

  if (resolving.length > 1) {
    return ' (' + resolving.map(_util.toString).join(' -> ') + ')';
  }

  return '';
}

// Injector encapsulate a life scope.
// There is exactly one instance for given token in given injector.
//
// All the state is immutable, the only state changes is the cache. There is however no way to produce different instance under given token. In that sense it is immutable.
//
// Injector is responsible for:
// - resolving tokens into
//   - provider
//   - value (cache/calling provider)
// - dealing with isPromise
// - dealing with isLazy
// - loading different "providers" and modules

var Injector = function () {
  function Injector() {
    var modules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var parentInjector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var providers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();
    var scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    _classCallCheck(this, Injector);

    this._cache = new Map();
    this._providers = providers;
    this._parent = parentInjector;
    this._scopes = scopes;

    this._loadModules(modules);

    (0, _profiler.profileInjector)(this, Injector);
  }

  // Collect all registered providers that has given annotation.
  // Including providers defined in parent injectors.


  _createClass(Injector, [{
    key: '_collectProvidersWithAnnotation',
    value: function _collectProvidersWithAnnotation(annotationClass, collectedProviders) {
      this._providers.forEach(function (provider, token) {
        if (!collectedProviders.has(token) && (0, _annotations.hasAnnotation)(provider.provider, annotationClass)) {
          collectedProviders.set(token, provider);
        }
      });

      if (this._parent) {
        this._parent._collectProvidersWithAnnotation(annotationClass, collectedProviders);
      }
    }

    // Load modules/function/classes.
    // This mutates `this._providers`, but it is only called during the constructor.

  }, {
    key: '_loadModules',
    value: function _loadModules(modules) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var module = _step.value;

          // A single provider (class or function).
          if ((0, _util.isFunction)(module)) {
            this._loadFnOrClass(module);
            continue;
          }

          throw new Error('Invalid module!');
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // Load a function or class.
    // This mutates `this._providers`, but it is only called during the constructor.

  }, {
    key: '_loadFnOrClass',
    value: function _loadFnOrClass(fnOrClass) {
      // TODO(vojta): should we expose provider.token?
      var annotations = (0, _annotations.readAnnotations)(fnOrClass);
      var token = annotations.provide.token || fnOrClass;
      var provider = (0, _providers.createProviderFromFnOrClass)(fnOrClass, annotations);

      this._providers.set(token, provider);
    }

    // Returns true if there is any provider registered for given token.
    // Including parent injectors.

  }, {
    key: '_hasProviderFor',
    value: function _hasProviderFor(token) {
      if (this._providers.has(token)) {
        return true;
      }

      if (this._parent) {
        return this._parent._hasProviderFor(token);
      }

      return false;
    }

    // Find the correct injector where the default provider should be instantiated and cached.

  }, {
    key: '_instantiateDefaultProvider',
    value: function _instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy) {
      // In root injector, instantiate here.
      if (!this._parent) {
        this._providers.set(token, provider);
        return this.get(token, resolving, wantPromise, wantLazy);
      }

      // Check if this injector forces new instance of this provider.
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._scopes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var ScopeClass = _step2.value;

          if ((0, _annotations.hasAnnotation)(provider.provider, ScopeClass)) {
            this._providers.set(token, provider);
            return this.get(token, resolving, wantPromise, wantLazy);
          }
        }

        // Otherwise ask parent injector.
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return this._parent._instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy);
    }

    // Return an instance for given token.

  }, {
    key: 'get',
    value: function get(token) {
      var resolving = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var wantPromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var _this = this;

      var wantLazy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var skipCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      var resolvingMsg = '';
      var provider;
      var instance;
      var injector = this;

      if (token === null || token === undefined) {
        resolvingMsg = constructResolvingMessage(resolving, token);
        throw new Error('Invalid token "' + token + '" requested!' + resolvingMsg);
      }

      // Special case, return itself.
      if (token === Injector) {
        if (wantPromise) {
          return Promise.resolve(this);
        }

        return this;
      }

      // TODO(vojta): optimize - no child injector for locals?
      if (wantLazy) {
        return function createLazyInstance() {
          var lazyInjector = injector;

          if (arguments.length) {
            var locals = [];
            var args = arguments;

            for (var i = 0; i < args.length; i += 2) {
              locals.push(function (ii) {
                var fn = function createLocalInstance() {
                  return args[ii + 1];
                };

                (0, _annotations.annotate)(fn, new _annotations.Provide(args[ii]));

                return fn;
              }(i));
            }

            lazyInjector = injector.createChild(locals);
          }

          return lazyInjector.get(token, resolving, wantPromise, false);
        };
      }

      // Check if there is a cached instance already.
      if (!skipCache && this._cache.has(token)) {
        instance = this._cache.get(token);
        provider = this._providers.get(token);

        if (provider.isPromise && !wantPromise) {
          resolvingMsg = constructResolvingMessage(resolving, token);
          throw new Error('Cannot instantiate ' + (0, _util.toString)(token) + ' synchronously. It is provided as a promise!' + resolvingMsg);
        }

        if (!provider.isPromise && wantPromise) {
          return Promise.resolve(instance);
        }

        return instance;
      }

      provider = this._providers.get(token);

      // No provider defined (overridden), use the default provider (token).
      if (!provider && (0, _util.isFunction)(token) && !this._hasProviderFor(token)) {
        provider = (0, _providers.createProviderFromFnOrClass)(token, (0, _annotations.readAnnotations)(token));
        return this._instantiateDefaultProvider(provider, token, resolving, wantPromise, wantLazy);
      }

      if (!provider) {
        if (!this._parent) {
          resolvingMsg = constructResolvingMessage(resolving, token);
          throw new Error('No provider for ' + (0, _util.toString)(token) + '!' + resolvingMsg);
        }

        return this._parent.get(token, resolving, wantPromise, wantLazy);
      }

      if (resolving.indexOf(token) !== -1) {
        resolvingMsg = constructResolvingMessage(resolving, token);
        throw new Error('Cannot instantiate cyclic dependency!' + resolvingMsg);
      }

      resolving.push(token);

      // TODO(vojta): handle these cases:
      // 1/
      // - requested as promise (delayed)
      // - requested again as promise (before the previous gets resolved) -> cache the promise
      // 2/
      // - requested as promise (delayed)
      // - requested again sync (before the previous gets resolved)
      // -> error, but let it go inside to throw where exactly is the async provider
      var delayingInstantiation = wantPromise && provider.params.some(function (param) {
        return !param.isPromise;
      });
      var args = provider.params.map(function (param) {

        if (delayingInstantiation) {
          return _this.get(param.token, resolving, true, param.isLazy);
        }

        return _this.get(param.token, resolving, param.isPromise, param.isLazy);
      });

      // Delaying the instantiation - return a promise.
      if (delayingInstantiation) {
        var delayedResolving = resolving.slice(); // clone

        resolving.pop();

        // Once all dependencies (promises) are resolved, instantiate.
        return Promise.all(args).then(function (args) {
          try {
            instance = provider.create(args);
          } catch (e) {
            resolvingMsg = constructResolvingMessage(delayedResolving);
            var originalMsg = 'ORIGINAL ERROR: ' + e.message;
            e.message = 'Error during instantiation of ' + (0, _util.toString)(token) + '!' + resolvingMsg + '\n' + originalMsg;
            throw e;
          }

          if (!(0, _annotations.hasAnnotation)(provider.provider, _annotations.TransientScope)) {
            injector._cache.set(token, instance);
          }

          // TODO(vojta): if a provider returns a promise (but is not declared as @ProvidePromise),
          // here the value will get unwrapped (because it is returned from a promise callback) and
          // the actual value will be injected. This is probably not desired behavior. Maybe we could
          // get rid off the @ProvidePromise and just check the returned value, whether it is
          // a promise or not.
          return instance;
        });
      }

      try {
        instance = provider.create(args);
      } catch (e) {
        resolvingMsg = constructResolvingMessage(resolving);
        var originalMsg = 'ORIGINAL ERROR: ' + e.message;
        e.message = 'Error during instantiation of ' + (0, _util.toString)(token) + '!' + resolvingMsg + '\n' + originalMsg;
        throw e;
      }

      if (!(0, _annotations.hasAnnotation)(provider.provider, _annotations.TransientScope)) {
        this._cache.set(token, instance);
      }

      if (!wantPromise && provider.isPromise) {
        resolvingMsg = constructResolvingMessage(resolving);

        throw new Error('Cannot instantiate ' + (0, _util.toString)(token) + ' synchronously. It is provided as a promise!' + resolvingMsg);
      }

      if (wantPromise && !provider.isPromise) {
        instance = Promise.resolve(instance);
      }

      resolving.pop();

      return instance;
    }
  }, {
    key: 'instantiate',
    value: function instantiate(token) {
      var resolving = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var wantPromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var wantLazy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var skipCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      return this.get(token, resolving, wantPromise, wantLazy, true);
    }
  }, {
    key: 'getPromise',
    value: function getPromise(token) {
      return this.get(token, [], true);
    }

    // Create a child injector, which encapsulate shorter life scope.
    // It is possible to add additional providers and also force new instances of existing providers.

  }, {
    key: 'createChild',
    value: function createChild() {
      var modules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var forceNewInstancesOf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var forcedProviders = new Map();

      // Always force new instance of TransientScope.
      forceNewInstancesOf.push(_annotations.TransientScope);

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = forceNewInstancesOf[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var annotation = _step3.value;

          this._collectProvidersWithAnnotation(annotation, forcedProviders);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return new Injector(modules, this, forcedProviders, forceNewInstancesOf);
    }
  }]);

  return Injector;
}();

exports.Injector = Injector;