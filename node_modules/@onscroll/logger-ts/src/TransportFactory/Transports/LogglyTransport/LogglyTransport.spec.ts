import {Injector} from "@onscroll/di-ts";
import {expect} from "chai";
import {LogglyTransport} from "./LogglyTransport";
import {BunyanLoggerFactoryMock} from "./BunyanLoggerFactory/BunyanLoggerFactoryMock";
import {SpyProvider} from "@onscroll/spy-provider";
import {BunyanLoggerMock} from "./BunyanLoggerFactory/BunyanLoggerMock";

const injector = new Injector([BunyanLoggerFactoryMock]),
    logglyTransport: LogglyTransport = injector.get(LogglyTransport);

logglyTransport.initialize({
    name: "mockName",
    token: "mockToken",
    subdomain: "mockSubdomain"
});


describe("LogglyTransport", () => {

    let loggerInfoSpy,
        loggerDebugSpy,
        loggerErrorSpy;

    beforeEach(() => {

        loggerInfoSpy = SpyProvider.getSpyFor(BunyanLoggerMock, "info");
        loggerDebugSpy = SpyProvider.getSpyFor(BunyanLoggerMock, "debug");
        loggerErrorSpy = SpyProvider.getSpyFor(BunyanLoggerMock, "error");

    });

    afterEach(() => {

        loggerInfoSpy.reset();
        loggerDebugSpy.reset();
        loggerErrorSpy.reset();

    });


    describe("when asked to log debug message", () => {

        it("should call bunyan debug method", () => {

            logglyTransport.debug("msg");
            expect(loggerDebugSpy.called).to.be.equal(true);

        });

    });

    describe("when asked to log info message", () => {

        it("should call bunyan info method", () => {

            logglyTransport.info("msg");
            expect(loggerInfoSpy.called).to.be.equal(true);

        });

    });

    describe("when asked to log error message", () => {

        it("should call bunyan error method", () => {

            logglyTransport.error("msg");
            expect(loggerErrorSpy.called).to.be.equal(true);

        });

    });

    describe("when asked to prepare message", () => {

        const mockTag = "mock-tag";

        describe("when message is a string", () => {

            const message = "sample message",
                preparedMessage = logglyTransport.prepareMessage(message, "", mockTag);

            it("should change message into an object with message key", () => {

                expect(preparedMessage).to.be.an.instanceOf(Object);
                expect(preparedMessage.message).to.equal("sample message");

            });

            it("should add a tag field", () => {

                expect(preparedMessage.tag).to.equal(mockTag);

            });


        });

        describe("when message is an object", () => {

            const message = {
                    message: "sample message"
                },
                preparedMessage = logglyTransport.prepareMessage(message, "log-level", mockTag);


            it("should return same object", () => {

                expect(preparedMessage.message).to.deep.equal(message.message);

            });

            it("should add a tag field", () => {

                expect(preparedMessage.tag).to.equal(mockTag);

            });
        });


        describe("when message is an error", () => {

            const error = new Error("Mock error"),
                preparedMessage = logglyTransport.prepareMessage(error, "log-level", mockTag);

            it("should return same error", () => {

                expect(preparedMessage.error).to.equal(error.message);
                expect(preparedMessage.stack).to.equal(error.stack);

            });

            it("should add a tag field", () => {

                expect(preparedMessage.tag).to.equal(mockTag);

            });
        });

        it("should add a log level into message object", () => {

            const message = "sample message",
                preparedMessage = logglyTransport.prepareMessage(message, "log-level", mockTag);

            expect(preparedMessage.label).to.equal("log-level");

        });

    });

});
