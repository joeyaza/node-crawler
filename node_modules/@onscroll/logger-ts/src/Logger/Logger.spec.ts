"use strict";

import {Injector} from "@onscroll/di-ts";
import {expect} from "chai";
import {Logger, LogLevel} from "./Logger";
import {TransportMock} from "../TransportFactory/Transports/TransportMock";
import {TransportFactoryMock} from "../TransportFactory/TransportFactoryMock";
import {SpyProvider} from "@onscroll/spy-provider";


const injector = new Injector([TransportFactoryMock]),
    logger: Logger = injector.get(Logger);

describe("Logger", () => {

    let transportFactorySpy;

    beforeEach(() => {

        transportFactorySpy = SpyProvider.getSpyFor(TransportFactoryMock, "createTransport");

    });

    afterEach(() => {

        transportFactorySpy.reset();

    });

    describe("when logging level is set to debug", () => {

        it("all debug, info, error functions should log a message", () => {

            logger.logLevel = LogLevel.DEBUG;
            expect(logger.debug("test")).to.equal(true);
            expect(logger.info("test")).to.equal(true);
            expect(logger.error("test")).to.equal(true);

        });

        it("all increment, decrement, gauge, gaugeDelta should send a value", () => {

            logger.logLevel = LogLevel.DEBUG;
            expect(logger.increment("test")).to.equal(true);
            expect(logger.decrement("test")).to.equal(true);
            expect(logger.gauge("test", 1)).to.equal(true);
            expect(logger.gaugeDelta("test", 1)).to.equal(true);

        });

    });

    describe("when logging level is set to info", () => {

        it("only info and error functions should log a message", () => {

            logger.logLevel = LogLevel.INFO;
            expect(logger.debug("test")).to.equal(false);
            expect(logger.info("test")).to.equal(true);
            expect(logger.error("test")).to.equal(true);

        });

        it("all increment, decrement, gauge, gaugeDelta should log a value", () => {

            logger.logLevel = LogLevel.INFO;
            expect(logger.increment("test")).to.equal(true);
            expect(logger.decrement("test")).to.equal(true);
            expect(logger.gauge("test", 1)).to.equal(true);
            expect(logger.gaugeDelta("test", 1)).to.equal(true);

        });

    });

    describe("when logging level is set to error", () => {


        it("only error functions should log a message", () => {
            logger.logLevel = LogLevel.ERROR;
            expect(logger.debug("test")).to.equal(false);
            expect(logger.info("test")).to.equal(false);
            expect(logger.error("test")).to.equal(true);

        });

        it("all increment, decrement, gauge, gaugeDelta should log a value", () => {

            logger.logLevel = LogLevel.ERROR;
            expect(logger.increment("test")).to.equal(true);
            expect(logger.decrement("test")).to.equal(true);
            expect(logger.gauge("test", 1)).to.equal(true);
            expect(logger.gaugeDelta("test", 1)).to.equal(true);

        });
    });


    describe("when asked to load the transports", () => {

        const transports = [
            {
                type: "loggly",
                enabled: true,
            },
            {
                type: "console",
                enabled: true
            }
        ];

        it("should pass log level to the transports", () => {

            logger.logLevel = LogLevel.DEBUG;
            logger.parseTransports([
                {
                    type: "mockType",
                    enabled: true
                }
            ]);

            expect(transportFactorySpy.args[0][2]).to.equal(LogLevel.DEBUG);


        });

        describe("when name is not defined in transport options", () => {

            it("should use the logger name as a name of the transport", () => {

                logger.parseTransports([
                    {
                        type: "mockType",
                        enabled: true,
                        options: {
                            mockField: ""
                        }
                    }
                ]);
                expect(transportFactorySpy.args[0][0]).to.equal("mockType");
                expect(transportFactorySpy.args[0][1].name).to.equal("mockLoggerName");
                expect(transportFactorySpy.called).to.equal(true);


            });

        });

        describe("when name is defined in transport options", () => {

            it("should not override the name", () => {

                logger.parseTransports([
                    {
                        type: "mockType",
                        enabled: true,
                        options: {
                            mockField: "",
                            name: "notLoggerName"
                        }
                    }
                ]);
                expect(transportFactorySpy.args[0][0]).to.equal("mockType");
                expect(transportFactorySpy.args[0][1].name).to.equal("notLoggerName");
                expect(transportFactorySpy.called).to.equal(true);


            });

        });

        describe("when two transports are enabled", () => {

            it("should load two instances of transport", () => {

                const transportList = logger.parseTransports(transports);
                expect(transportList.length).to.equal(2);

            });

        });


        describe("when only one transport is enabled", () => {

            it("should load only one instance of transport", () => {

                transports[1].enabled = false;
                const transportList = logger.parseTransports(transports);
                expect(transportList.length).to.equal(1);

            });


        });


    });


    describe("when asked to write log message", () => {

        let logSpy;

        beforeEach(() => {

            logSpy = SpyProvider.getSpyFor("TransportMock", "log");

        });

        it("should call a correct transport", () => {

            logger.error("test");
            expect(logSpy.called).to.equal(true);


        });

    });


});
