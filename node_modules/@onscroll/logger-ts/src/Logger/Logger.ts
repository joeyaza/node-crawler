import {AbstractTransport} from "../TransportFactory/Transports/AbstractTransport";
"use strict";

import * as _ from "lodash";
import {Inject} from "@onscroll/di-ts";
import {TransportFactory} from "../TransportFactory/TransportFactory";
import {Configure} from "@onscroll/configurator";

@Inject
export class Logger {

    public logLevel: LogLevel;
    private transports: AbstractTransport[];

    @Configure("Logger")
    private config;

    constructor(private transportFactory: TransportFactory) {

        this.logLevel = LogLevel[this.config.level as string];
        this.transports = this.parseTransports(this.config.transports);

    }


    public debug(message: any): boolean {

        return this.writeLog(LogLevel.DEBUG, message);

    }

    public info(message: any): boolean {

        return this.writeLog(LogLevel.INFO, message);

    }

    public log(message: any): boolean {

        return this.writeLog(LogLevel.DEBUG, message);

    }

    public error(message: any): boolean {

        return this.writeLog(LogLevel.ERROR, message);

    }

    public increment(fieldName: string, delta: number = 1): boolean {

        return this.updateMetrics("increment", fieldName, delta);
    }

    public decrement(fieldName: string, delta: number = 1): boolean {

        return this.updateMetrics("decrement", fieldName, delta);
    }

    public gauge(fieldName: string, value: number): boolean {

        return this.updateMetrics("gauge", fieldName, value);
    }

    public gaugeDelta(fieldName: string, value: number): boolean {

        return this.updateMetrics("gaugeDelta", fieldName, value);

    }


    public parseTransports(transportSettings: any): AbstractTransport[] {

        return _.chain(transportSettings).filter("enabled").map((settings: any) => {

            const options = this.setDefaultOptions(settings.options);

            return this.transportFactory.createTransport(settings.type, options, this.logLevel);

        }).value();

    }


    private writeLog(logLevel: LogLevel, message: any): boolean {

        if (!this.isSupportedLevel(logLevel)) {

            return false;

        }

        _.each(this.transports, (transport: AbstractTransport) => {

            transport.log(logLevel, message);

        });

        return true;

    }


    private updateMetrics(method: string, ...args: any[]): boolean {

        _.each(this.transports, (transport: AbstractTransport) => {

            transport[method].apply(transport, args);

        });

        return true;

    }


    private isSupportedLevel(logLevel: LogLevel) {

        return logLevel >= this.logLevel;

    }


    private setDefaultOptions(options: any) {

        if (!options) {

            return options;

        }

        if (!options.name) {

            options.name = this.config.name;
        }

        return options;

    }
}

export enum LogLevel {
    DEBUG,
    INFO,
    ERROR,
}
